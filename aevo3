-- Auto Script for AEVO
--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local StatsService = game:GetService("Stats")
local TeleportService = game:GetService("TeleportService")
local CoreGui = game:GetService("CoreGui")

--// Connection Management
if getgenv().AX_ActiveConnections then
    for _, conn in pairs(getgenv().AX_ActiveConnections) do
        if conn then conn:Disconnect() end
    end
end
local Connections = {}
getgenv().AX_ActiveConnections = Connections

local function AddConnection(conn)
    table.insert(Connections, conn)
end

--// Player / Remotes
local player = Players.LocalPlayer
local username = player.Name
local displayName = player.DisplayName
local playerGui = player:WaitForChild("PlayerGui")

local Bridge = ReplicatedStorage:WaitForChild("Bridge", 10)
local Engagement = ReplicatedStorage:WaitForChild("_EngagementRewards", 10)

if not Bridge or not Engagement then
    warn("AEVO: Critical Remotes not found. Script stopped.")
    return
end
Engagement = Engagement:WaitForChild("RemoteEvent")

getgenv().AFK = true
getgenv().AEVO_Loaded = true
getgenv().Webhook = "https://discord.com/api/webhooks/1455357970433966131/hEnrOFbx24-1LuyA8o4lv5GHGBZMlzTIueGoYRbmDGkIfRk5jubp_ucA1BxVti7_zGks" 

--// Constants & Configuration Tables
local Settings = {
    AutoRank = false,
    AutoAura = false,
    AutoEquip = false,
    AutoRaid = false,
    AutoHatch = false,
    WorldBoss = false,
    RuneSword = false,
    dCareppl = true,
    SoloRaid = false,
    SoloRaidMode = "Divinity",
    MapLocations = {},
    Rendering3D = true,
    EggFrame = true,
    dStatus = false,
    rtimeOut = false,
    getSouls = false,
    MapSelected = "Sacred Forest",
    Webhook = getgenv().Webhook or "",
    -- New Stats Tracking
    RaidStats = { Today = 0, Month = 0 },
    WBStats = { Today = 0, Month = 0 },
    rStatus = 0,
    LastExecDate = "",
    LastDateChecked = "",
    LastMonthChecked = "",
    ClaimedToday = false
}

-- Dynamic State
local State = {
    inRaid = false,
    inAbuseRaid = false,
    inLost = false,
    raidMap = nil,
    tpBoss = false,
    mapToReturn = nil,
    extRaid = false,
    wbSpawn = false,
    StartTime = tick(),
    RaidCount = 0, -- Session Count
    WBCount = 0,   -- Session Count
    LastRaidFinish = 0,
    RaidStartTimestamp = 0,
    LastDiscordStatus = 0,
    tpWBossAltar = math.random(30, 45),
    tpgetSouls = false,
    BossConnections = {},
    BossQueue = nil -- Store next boss to trigger after current fight
}

local FolderName = "aevo"
local FileName = username .. ".json"
local FullPath = FolderName .. "/" .. FileName

if not isfolder(FolderName) then makefolder(FolderName) end

--// Helper Functions
local function _pn() return displayName .. "(@" .. username .. ") " end
local function _ts() return " (" .. os.date("%H:%M:%S") .. ")" end

local function Notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title, 
        Text = text, 
        Duration = 3
    })
end

--// Discord Function
local dDebounce = false
local function SendDiscord(message, isEmbed, isExec)
    local dWebhook = ""
    if isExec then
        dWebhook = "https://discord.com/api/webhooks/1465181203026940110/e4VuZC5PHiINsTg-_Vc2wuXKxGEOGdMRqFy3PCJFEGT6Z27zlcqWTTpHFuwCbXKbcKV7"
    else
        if dDebounce or Settings.Webhook == "" then return end
        dWebhook = Settings.Webhook
    end

    dDebounce = true
    task.spawn(function()
        local http = game:GetService("HttpService")
        local headers = { ["Content-Type"] = "application/json" }
        local data
        
        if isEmbed then
            data = {
                ["username"] = "AEVO",
                ["avatar_url"] = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=420&height=420&format=png",
                ["embeds"] = { message }
            }
        else
            data = { ["content"] = "üë§" .. _pn() .. message .. _ts() }
        end

        local ok = pcall(function() 
            request({ Url = dWebhook, Method = "POST", Headers = headers, Body = http:JSONEncode(data) }) 
        end)
        task.wait(2)
        dDebounce = false
    end)
end

--// ANTI-DISCONNECT
local function JoinRandomServer()
    local servers = {}
    local req = request({Url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)})
    local body = HttpService:JSONDecode(req.Body)
    if body and body.data then
        for i, v in next, body.data do
            if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.id ~= game.JobId then
                table.insert(servers, 1, v.id)
            end
        end
    end
    
    if queue_on_teleport and getgenv().AFK then
        queue_on_teleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/adi3yzz/rblx/refs/heads/main/aevo7"))()')
    end

    if #servers > 0 then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], Players.LocalPlayer)
    else
        TeleportService:Teleport(game.PlaceId, Players.LocalPlayer)
    end
end

AddConnection(CoreGui.RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
    if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
        SendDiscord("‚ö†Ô∏è **DISCONNECTED!** Attempting to auto-reconnect...", false)
        task.wait(10)
        JoinRandomServer()
    end
end))

--// Anti-AFK
AddConnection(player.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end))

--// Cleanup UI
for _, gui in ipairs(playerGui:GetChildren()) do
    if gui:IsA("ScreenGui") and gui.Name == "AutoUI" then 
        gui:Destroy() 
    end
end

local Scheduler = {}
Scheduler.timers = {
    AutoRank = { time = 0, delay = 15 },
    AutoAura = { time = 0, delay = 15 },
    AutoEquip = { time = 0, delay = 900 },
    AutoHatch = { time = nil, delay = 900 },
}

local function _cmap()
    local c = Workspace:FindFirstChild("Client")
    local mf = c and c:FindFirstChild("Maps")
    local cm = mf and #mf:GetChildren() > 0 and mf:GetChildren()[1]
    return cm and cm.Name or "Sacred Forest"
end

local NewRaidMaps = {"Raid_Abuse", "Raid_DemonSlayer", "Raid_Crystal", "Raid_Crazy", "Raid_Insane"}
local SoloRaidMaps = {"Raid", "Raid_02", "Raid_03", "Raid_04", "Raid_Divinity", "Raid_Christmas", "Raid_HW"}
local SoloRaidModesMap = {
    ["Easy"]      = "Raid", 
    ["Medium"]    = "Raid_02", 
    ["Hard"]      = "Raid_03", 
    ["Infinity"]  = "Raid_04",
    ["Divinity"]  = "Raid_Divinity",
    ["Christmas"] = "Raid_Christmas",
    ["Halloween"] = "Raid_HW"
}

--// Raid Settings 
local RaidSettings = {
    ["DemonSlayer"] = { map = "Raid_DemonSlayer", enabled = true },
    ["Crystal"]     = { map = "Raid_Crystal", enabled = true },
    ["Crazy"]       = { map = "Raid_Crazy", enabled = true },
    ["Insane"]      = { map = "Raid_Insane", enabled = true },
    ["Abuse"]       = { map = "Raid_Abuse", enabled = true },
}

local mapList = {
    "Sacred Forest", "Goblins Caves", "Lost Temple", "Sands", "Subway", "City",
    "Anthill", "Fiery World", "Mines", "Shadow Castle", "Frozen Forest",
    "Orc Sanctuary", "Demonic World", "Ant Island", "Volcano", "Gloomridge",
    "Murimu Village", "Cairo", "Divide Garden", "Spirit", "Shantytown",
    "Fireworkers", "Sayan Valley", "Grand Sea", "Ninja Village",
    "Swordsman Village", "Walled City", "Superhuman Academy", "Shield Kingdom",
    "Alchemy City",
 }

--// World Boss Settings (CONVERTED TO UTC)
local wbossMaps = {
    -- Divide Angel Bosses
    { map = "Sacred Forest",      type = "Divine Angel", time = { "04:30", "13:30", "21:00" }, pos = Vector3.new(1445.426, 171.390, -129.533), enabled = true },
    { map = "Goblins Caves",      type = "Divine Angel", time = { "04:45", "13:45", "21:15" }, pos = Vector3.new(25963.426, 140.477, 6553.327), enabled = true },
    { map = "Lost Temple",        type = "Divine Angel", time = { "05:00", "14:00", "21:30" }, pos = Vector3.new(115.908, 153.246, 4648.430), enabled = true },
    { map = "Sands",              type = "Divine Angel", time = { "05:15", "14:15", "21:45" }, pos = Vector3.new(25747.734, 155.795, 13359.888), enabled = true },
    { map = "Subway",             type = "Divine Angel", time = { "05:30", "14:30", "22:00" }, pos = Vector3.new(-7553.564, 109.834, 507.993), enabled = true },
    { map = "City",               type = "Divine Angel", time = { "05:45", "14:45", "22:15" }, pos = Vector3.new(1027.331, -222.485, -9716.860), enabled = true },
    { map = "Anthill",            type = "Divine Angel", time = { "06:00", "15:00", "22:30" }, pos = Vector3.new(-2383.421, 18.179, 27410.584), enabled = true },
    { map = "Fiery World",        type = "Divine Angel", time = { "06:15", "15:15", "22:45" }, pos = Vector3.new(-53691.172, 15.605, 530.161), enabled = true },
    { map = "Mines",              type = "Divine Angel", time = { "06:30", "15:30", "23:00" }, pos = Vector3.new(7778.679, 178.738, 3662.787), enabled = true },
    { map = "Shadow Castle",      type = "Divine Angel", time = { "06:45", "15:45", "23:15" }, pos = Vector3.new(20907.422, 150.181, 3631.185), enabled = true },
    { map = "Frozen Forest",      type = "Divine Angel", time = { "07:00", "16:00", "23:30" }, pos = Vector3.new(10551.888, 169.223, -12080.329), enabled = true },
    { map = "Orc Sanctuary",      type = "Divine Angel", time = { "07:15", "16:15", "23:45" }, pos = Vector3.new(21910.891, 473.661, -59413.441), enabled = true },
    { map = "Demonic World",      type = "Divine Angel", time = { "07:30", "09:00", "16:30", "00:00" }, pos = Vector3.new(-17339.252, 15.616, -2772.876), enabled = true },
    { map = "Ant Island",         type = "Divine Angel", time = { "07:45", "09:15", "16:45", "00:15" }, pos = Vector3.new(725.516, 16.819, 13306.611), enabled = true },
    { map = "Volcano",            type = "Divine Angel", time = { "08:00", "09:30", "17:00", "00:30" }, pos = Vector3.new(-12525.777, 169.043, -3383.367), enabled = true },
    { map = "Gloomridge",         type = "Divine Angel", time = { "08:15", "09:45", "17:15", "00:45" }, pos = Vector3.new(-20787.246, 917.716, 13453.386), enabled = true },
    { map = "Murimu Village",     type = "Divine Angel", time = { "08:30", "10:00", "17:30", "01:00" }, pos = Vector3.new(-13881.711, 942.633, 11838.305), enabled = true },
    { map = "Cairo",              type = "Divine Angel", time = { "08:45", "10:15", "17:45", "01:15" }, pos = Vector3.new(-2693.459, 943.177, 36725.582), enabled = true },
    { map = "Divide Garden",      type = "Divine Angel", time = { "10:30", "18:00", "01:30" }, pos = Vector3.new(-18423.959, 953.529, 22321.719), enabled = true },
    { map = "Spirit",             type = "Divine Angel", time = { "10:45", "18:15", "01:45" }, pos = Vector3.new(-17385.016, 1018.581, 17980.191), enabled = true },
    { map = "Shantytown",         type = "Divine Angel", time = { "11:00", "18:30", "02:00" }, pos = Vector3.new(-24918.287, 1030.996, 36445.289), enabled = false },
    { map = "Fireworkers",        type = "Divine Angel", time = { "11:15", "18:45", "02:15" }, pos = Vector3.new(-21825.266, 1029.995, 18863.006), enabled = false },
    { map = "Sayan Valley",       type = "Divine Angel", time = { "11:30", "19:00", "02:30" }, pos = Vector3.new(-28177.160, 1031.086, 13608.544), enabled = false },
    { map = "Grand Sea",          type = "Divine Angel", time = { "11:45", "19:15", "02:45" }, pos = Vector3.new(-40951.098, 1026.935, 13444.108), enabled = false },
    { map = "Ninja Village",      type = "Divine Angel", time = { "12:00", "19:30", "03:00" }, pos = Vector3.new(-25011.105, 1430.081, 5456.884), enabled = false },
    { map = "Swordsman Village",  type = "Divine Angel", time = { "12:15", "19:45", "03:15" }, pos = Vector3.new(-16133.434, 414.092, 13808.948), enabled = false },
    { map = "Walled City",        type = "Divine Angel", time = { "12:30", "20:00", "03:30" }, pos = Vector3.new(10294.787, 39.311, -32443.898), enabled = false },
    { map = "Superhuman Academy", type = "Divine Angel", time = { "12:45", "20:15", "03:45" }, pos = Vector3.new(9925.527, 39.321, -36586.801), enabled = false },
    { map = "Shield Kingdom",     type = "Divine Angel", time = { "13:00", "20:30", "04:00" }, pos = Vector3.new(-25248.926, 1513.016, 679.571), enabled = false },
    { map = "Alchemy City",       type = "Divine Angel", time = { "13:15", "20:45", "04:15" }, pos = Vector3.new(-24192.365, 1410.815, -4001.184), enabled = false },
    -- Regular World Bosses
    { map = "Sacred Forest",      type = "World Boss", time = { "04:00", "09:00", "14:00", "19:00", "00:00" }, pos = Vector3.new(1337, 171, -305), enabled = true },
    { map = "Goblins Caves",      type = "World Boss", time = { "04:10", "09:10", "14:10", "19:10", "00:10" }, pos = Vector3.new(26050.852, 125.539, 6473.761), enabled = true },
    { map = "Lost Temple",        type = "World Boss", time = { "04:20", "09:20", "14:20", "19:20", "00:20" }, pos = Vector3.new(152.685, 154.536, 4560.959), enabled = true },
    { map = "Sands",              type = "World Boss", time = { "04:30", "09:30", "14:30", "19:30", "00:30" }, pos = Vector3.new(25820, 156, 13252), enabled = true },
    { map = "Subway",             type = "World Boss", time = { "04:40", "09:40", "14:40", "19:40", "00:40" }, pos = Vector3.new(-7581.820, 87.507, 311.941), enabled = true },
    { map = "City",               type = "World Boss", time = { "04:50", "09:50", "14:50", "19:50", "00:50" }, pos = Vector3.new(557, -222, -9883), enabled = true },
    { map = "Anthill",            type = "World Boss", time = { "05:00", "10:00", "15:00", "20:00", "01:00" }, pos = Vector3.new(-2371.800, 16.853, 27290.389), enabled = true },
    { map = "Fiery World",        type = "World Boss", time = { "05:10", "10:10", "15:10", "20:10" }, pos = Vector3.new(-53734, 14, 144), enabled = true },
    { map = "Mines",              type = "World Boss", time = { "05:20", "10:20", "15:20", "20:20" }, pos = Vector3.new(7324.803, 178.560, 3817.395), enabled = true },
    { map = "Shadow Castle",      type = "World Boss", time = { "05:30", "10:30", "15:30", "20:30" }, pos = Vector3.new(20940.594, 150.209, 3863.320), enabled = true },
    { map = "Frozen Forest",      type = "World Boss", time = { "05:40", "10:40", "15:40", "20:40" }, pos = Vector3.new(10490.367, 169.446, -11804.771), enabled = true },
    { map = "Orc Sanctuary",      type = "World Boss", time = { "05:50", "10:50", "15:50", "20:50" }, pos = Vector3.new(21238.350, 459.016, -59115.410), enabled = true },
    { map = "Demonic World",      type = "World Boss", time = { "06:00", "11:00", "16:00", "21:00" }, pos = Vector3.new(-17462.604, 34.273, -3142.330), enabled = true },
    { map = "Ant Island",         type = "World Boss", time = { "01:10", "06:10", "11:10", "16:10", "21:10" }, pos = Vector3.new(382.004, 20.144, 13499.070), enabled = true },
    { map = "Volcano",            type = "World Boss", time = { "01:20", "06:20", "11:20", "16:20", "21:20" }, pos = Vector3.new(-12629.971, 168.581, -3230.433), enabled = true },
    { map = "Gloomridge",         type = "World Boss", time = { "01:30", "06:30", "11:30", "16:30", "21:30" }, pos = Vector3.new(-20444.883, 922.603, 13636.362), enabled = true },
    { map = "Murimu Village",     type = "World Boss", time = { "01:40", "06:40", "11:40", "16:40", "21:40" }, pos = Vector3.new(-13820.382, 943.605, 11732.551), enabled = true },
    { map = "Cairo",              type = "World Boss", time = { "01:50", "06:50", "11:50", "16:50", "21:50" }, pos = Vector3.new(-3084.695, 943.262, 36210.180), enabled = true },
    { map = "Divide Garden",      type = "World Boss", time = { "02:00", "07:00", "12:00", "17:00", "22:00" }, pos = Vector3.new(-18647.818, 953.618, 22124.344), enabled = true },
    { map = "Spirit",             type = "World Boss", time = { "02:10", "07:10", "12:10", "17:10", "22:10" }, pos = Vector3.new(-17344.240, 1019.479, 18161.121), enabled = true },
    { map = "Shantytown",         type = "World Boss", time = { "02:20", "07:20", "12:20", "17:20", "22:20" }, pos = Vector3.new(-24867.816, 1022.057, 36675.758), enabled = false },
    { map = "Fireworkers",        type = "World Boss", time = { "02:30", "07:30", "12:30", "17:30", "22:30" }, pos = Vector3.new(-21822.660, 1019.995, 18867.775), enabled = false },
    { map = "Sayan Valley",       type = "World Boss", time = { "02:40", "07:40", "12:40", "17:40", "22:40" }, pos = Vector3.new(-28155.615, 1020.859, 13780.623), enabled = false },
    { map = "Grand Sea",          type = "World Boss", time = { "02:50", "07:50", "12:50", "17:50", "22:50" }, pos = Vector3.new(-40929.156, 1022.185, 13586.221), enabled = false },
    { map = "Ninja Village",      type = "World Boss", time = { "03:00", "08:00", "13:00", "18:00", "23:00" }, pos = Vector3.new(-25472.373, 1498.981, 5266.060), enabled = false },
    { map = "Swordsman Village",  type = "World Boss", time = { "03:10", "08:10", "13:10", "18:10", "23:10" }, pos = Vector3.new(-15918.838, 404.988, 13648.081), enabled = false },
    { map = "Walled City",        type = "World Boss", time = { "03:20", "08:20", "13:20", "18:20", "23:20" }, pos = Vector3.new(10458.686, 30.238, -32543.113), enabled = false },
    { map = "Superhuman Academy", type = "World Boss", time = { "03:30", "08:30", "13:30", "18:30", "23:30" }, pos = Vector3.new(9793.622, 30.276, -36027.629), enabled = false },
    { map = "Shield Kingdom",     type = "World Boss", time = { "03:40", "08:40", "13:40", "18:40", "23:40" }, pos = Vector3.new(-25432.738, 1458.757, 648.762), enabled = false },
    { map = "Alchemy City",       type = "World Boss", time = { "03:50", "08:50", "13:50", "18:50", "23:50" }, pos = Vector3.new(-23297.723, 1409.747, -3520.881), enabled = false },
}

local OrderedBossNames = {
    "Sacred Forest", "Goblins Caves", "Lost Temple", "Sands", "Subway", "City",
    "Anthill", "Fiery World", "Mines", "Shadow Castle", "Frozen Forest",
    "Orc Sanctuary", "Demonic World", "Ant Island", "Volcano", "Gloomridge",
    "Murimu Village", "Cairo", "Divide Garden", "Spirit", "Shantytown",
    "Fireworkers", "Sayan Valley", "Grand Sea", "Ninja Village",
    "Swordsman Village", "Walled City", "Superhuman Academy", "Shield Kingdom",
    "Alchemy City"
}

-- validBossMaps replaced with direct iteration over wbossMaps array

local function serializeCFrame(cframe) 
    if cframe then return { x = cframe.X, y = cframe.Y, z = cframe.Z } end
    return nil
end

local function deserializeCFrame(tbl) 
    if tbl and tbl.x then return CFrame.new(tbl.x, tbl.y + 10, tbl.z) end
    return nil
end

local function formatSeconds(seconds)
    local days = math.floor(seconds / 86400)
    local hours = math.floor((seconds % 86400) / 3600)
    local minutes = math.floor((seconds % 3600) / 60)
    local secs = seconds % 60
    
    if days > 0 then
        return string.format("%d:%02d:%02d:%02d", days, hours, minutes, secs)
    else
        return string.format("%02d:%02d:%02d", hours, minutes, secs)
    end
end

local function getRuntime() 
    return formatSeconds(math.floor(tick() - State.StartTime)) 
end

local function getNextBossData()
    local t = os.date("!*t") -- Using UTC date
    local currentMinutes = t.hour * 60 + t.min
    local lowestDiff = 999999
    local nextBoss = nil
    
    for _, data in ipairs(wbossMaps) do
        if data.enabled then
            for _, timeStr in pairs(data.time) do
                local hStr, mStr = timeStr:match("(%d+):(%d+)")
                local h, m = tonumber(hStr), tonumber(mStr)
                
                if h and m then
                    local bossMinutes = h * 60 + m
                    local diff = bossMinutes - currentMinutes
                    
                    if diff < 0 then diff = diff + (24 * 60) end 
                    
                    if diff < lowestDiff then
                        lowestDiff = diff
                        
                        nextBoss = { 
                            map = data.map, 
                            type = data.type,
                            diffSeconds = (diff * 60) - t.sec 
                        }
                    end
                end
            end
        end
    end
    
    return nextBoss
end

local function getNextRaidData()
    if not Settings.AutoRaid then return nil end

    local t = os.date("!*t") -- Using UTC date
    local currentSecs = (t.hour * 3600) + (t.min * 60) + t.sec
    local daySecs = 86400
    local potentialRaids = {}
    
    -- 1. Abuse Raid (UTC)
    if RaidSettings[Abuse].enabled and not State.inAbuseRaid then
        local abuseTimes = {3, 9, 15, 21} -- Changed from 11, 23 (GMT+8)
        for _, h in ipairs(abuseTimes) do
            local raidSecs = (h * 3600)
            local diff = raidSecs - currentSecs
            if diff < 0 then diff = diff + daySecs end
            table.insert(potentialRaids, { name = "Abuse", seconds = diff })
        end
    end

    -- 2. Standard Hourly Raids
    local schedules = {
        {min=0, key="DemonSlayer", name="Demon Slayer"},
        {min=15, key="Crystal", name="Crystal"},
        {min=30, key="Crazy", name="Crazy"},
        {min=45, key="Insane", name="Insane"}
    }
    
    for i = 0, 1 do
        local checkHour = (t.hour + i) % 24
        for _, raid in ipairs(schedules) do
             if RaidSettings[raid.key] and RaidSettings[raid.key].enabled then
                 local raidSecs = (checkHour * 3600) + (raid.min * 60)
                 local diff = raidSecs - currentSecs
                 if diff < 0 then diff = diff + daySecs end
                 table.insert(potentialRaids, { name = raid.name, seconds = diff })
             end
        end
    end

    table.sort(potentialRaids, function(a, b) return a.seconds < b.seconds end)
    if #potentialRaids > 0 then return potentialRaids[1] end
    return { name = "None", seconds = 0 }
end

local function SaveConfig()
    local wbPrefs = {}
    for _, data in ipairs(wbossMaps) do 
        wbPrefs[data.map] = data.enabled 
    end
    
    local raidPrefs = {}
    for name, data in pairs(RaidSettings) do raidPrefs[name] = data.enabled end

    local Config = {
        AutoRank = Settings.AutoRank, 
        AutoAura = Settings.AutoAura,
        AutoEquip = Settings.AutoEquip, 
        AutoRaid = Settings.AutoRaid,
        WorldBoss = Settings.WorldBoss, 
        AutoHatch = Settings.AutoHatch, 
        RuneSword = Settings.RuneSword,
        dCareppl = Settings.dCareppl, 
        Rendering3D = Settings.Rendering3D, 
        EggFrame = Settings.EggFrame,
        SoloRaid = Settings.SoloRaid, 
        SoloRaidMode = Settings.SoloRaidMode, 
        MapLocations = Settings.MapLocations,
        dStatus = Settings.dStatus,
        rtimeOut = Settings.rtimeOut,
        getSouls = Settings.getSouls,
        MapSelected = Settings.MapSelected,
        ClaimedToday = Settings.ClaimedToday,
        WBPrefs = wbPrefs, 
        RaidPrefs = raidPrefs,
        -- New Persistant Data
        RaidStats = Settings.RaidStats,
        WBStats = Settings.WBStats,
        rStatus = Settings.rStatus,
        LastExecDate = Settings.LastExecDate,
        LastDateChecked = Settings.LastDateChecked,
        LastMonthChecked = Settings.LastMonthChecked
    }

    local ok, json = pcall(function() return HttpService:JSONEncode(Config) end)
    if ok then writefile(FullPath, json) end
end

--// CHECK DAILY RESET FUNCTION (Uses Local Time os.time)
local function CheckDailyReset()
    local currentTime = os.time()
    local localDate = os.date("*t", currentTime)
    local todayStr = string.format("%04d-%02d-%02d", localDate.year, localDate.month, localDate.day)
    local monthStr = string.format("%04d-%02d", localDate.year, localDate.month)

    -- Check Daily Reset (Local Time)
    if Settings.LastDateChecked ~= todayStr then
        Settings.RaidStats.Today = 0
        Settings.WBStats.Today = 0
        Settings.LastDateChecked = todayStr
        SaveConfig()
    end

     -- Check Monthly Reset
    if Settings.LastMonthChecked ~= monthStr then
        Settings.RaidStats.Month = 0
        Settings.WBStats.Month = 0
        Settings.LastMonthChecked = monthStr
        SaveConfig()
    end
end

local function LoadConfig()
    if not isfile(FullPath) then return end
    local ok, data = pcall(function() return HttpService:JSONDecode(readfile(FullPath)) end)
    if not ok or not data then return end

    if data.AutoRank ~= nil then Settings.AutoRank = data.AutoRank end
    if data.AutoAura ~= nil then Settings.AutoAura = data.AutoAura end
    if data.AutoEquip ~= nil then Settings.AutoEquip = data.AutoEquip end
    if data.AutoRaid ~= nil then Settings.AutoRaid = data.AutoRaid end
    if data.WorldBoss ~= nil then Settings.WorldBoss = data.WorldBoss end
    if data.AutoHatch ~= nil then Settings.AutoHatch = data.AutoHatch end
    if data.MapSelected ~= nil then Settings.MapSelected = data.MapSelected end
    if data.RuneSword ~= nil then Settings.RuneSword = data.RuneSword end
    if data.dCareppl ~= nil then Settings.dCareppl = data.dCareppl end
    if data.Rendering3D ~= nil then Settings.Rendering3D = data.Rendering3D end
    if data.SoloRaid ~= nil then Settings.SoloRaid = data.SoloRaid end
    if data.SoloRaidMode ~= nil then Settings.SoloRaidMode = data.SoloRaidMode end
    if data.EggFrame ~= nil then Settings.EggFrame = data.EggFrame end
    if data.dStatus ~= nil then Settings.dStatus = data.dStatus end
    if data.rtimeOut ~= nil then Settings.rtimeOut = data.rtimeOut end
    if data.getSouls ~= nil then Settings.getSouls = data.getSouls end
    if data.ClaimedToday ~= nil then Settings.ClaimedToday = data.ClaimedToday end
    
    Settings.MapLocations = data.MapLocations or {}
    
    -- Load Stats
    if data.RaidStats then Settings.RaidStats = data.RaidStats end
    if data.WBStats then Settings.WBStats = data.WBStats end
    if data.rStatus then Settings.rStatus = data.rStatus end
    if data.LastExecDate then Settings.LastExecDate = data.LastExecDate end
    if data.LastDateChecked then Settings.LastDateChecked = data.LastDateChecked end
    if data.LastMonthChecked then Settings.LastMonthChecked = data.LastMonthChecked end

    if data.WBPrefs then 
        for bossMap, enabled in pairs(data.WBPrefs) do 
            for _, bossData in ipairs(wbossMaps) do
                if bossData.map == bossMap then
                    bossData.enabled = enabled
                end
            end
        end 
    end

    if data.RaidPrefs then 
        for name, enabled in pairs(data.RaidPrefs) do 
            if RaidSettings[name] then RaidSettings[name].enabled = enabled end 
        end 
    end

    CheckDailyReset()
end

LoadConfig()

local function getTimer(name) return Scheduler.timers[name] end

RunService:Set3dRenderingEnabled(Settings.Rendering3D)

local function destroyEggFrame()
    local _player = game:GetService("Players").LocalPlayer
    local _gui = _player:WaitForChild("PlayerGui")
    _gui.EggAnimation.Enabled = Settings.EggFrame
    _gui.OpenedUnits.Frame.List.Visible = Settings.EggFrame
end
destroyEggFrame()

--// UI Creation (Unchanged section kept brief)
local gui = Instance.new("ScreenGui")
gui.Name = "AutoUI"
gui.ResetOnSpawn = false
gui.DisplayOrder = 999
gui.Parent = playerGui

local main = Instance.new("Frame")
main.Name = "MainFrame"
main.Size = UDim2.new(0, 260, 0, 310)
main.Position = UDim2.new(0.5, -130, 0.5, -155)
main.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
main.BorderSizePixel = 0
Instance.new("UICorner", main).CornerRadius = UDim.new(0, 8)
local stroke = Instance.new("UIStroke", main)
stroke.Color = Color3.fromRGB(60, 60, 60)
stroke.Thickness = 1.5
main.Parent = gui

local titleBar = Instance.new("Frame", main)
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
local tbCover = Instance.new("Frame", titleBar)
tbCover.Size = UDim2.new(1, 0, 0, 10)
tbCover.Position = UDim2.new(0,0,1,-10)
tbCover.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
tbCover.BorderSizePixel = 0

local title = Instance.new("TextLabel", titleBar)
title.Size = UDim2.new(1, -30, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.Text = "‚öîÔ∏è Anime Evolution ‚öîÔ∏è"
title.TextColor3 = Color3.fromRGB(240, 240, 240)
title.TextXAlignment = Enum.TextXAlignment.Left

local close = Instance.new("TextButton", titleBar)
close.Size = UDim2.new(0, 20, 0, 20)
close.Position = UDim2.new(1, -25, 0.5, -10)
close.Text = "√ó"
close.Font = Enum.Font.GothamBold
close.TextSize = 18
close.TextColor3 = Color3.fromRGB(200, 200, 200)
close.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
close.BackgroundTransparency = 1
close.AutoButtonColor = true

local container = Instance.new("Frame", main)
container.Size = UDim2.new(1, -16, 0, 200)
container.Position = UDim2.new(0, 8, 0, 32)
container.BackgroundTransparency = 1
container.Parent = main

local uiGrid = Instance.new("UIGridLayout", container)
uiGrid.SortOrder = Enum.SortOrder.LayoutOrder
uiGrid.CellPadding = UDim2.new(0, 6, 0, 6)
uiGrid.CellSize = UDim2.new(0, 119, 0, 24)

local statusFrame = Instance.new("Frame", main)
statusFrame.Size = UDim2.new(1, -16, 0, 65)
statusFrame.Position = UDim2.new(0, 8, 1, -68)
statusFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Instance.new("UICorner", statusFrame).CornerRadius = UDim.new(0, 6)
local sStroke = Instance.new("UIStroke", statusFrame)
sStroke.Color = Color3.fromRGB(40, 40, 40)
sStroke.Transparency = 0.5
statusFrame.Parent = main

local line1 = Instance.new("TextLabel", statusFrame)
line1.Size = UDim2.new(1, -10, 0, 18)
line1.Position = UDim2.new(0, 5, 0, 5)
line1.BackgroundTransparency = 1
line1.Font = Enum.Font.GothamBold
line1.TextSize = 11
line1.TextColor3 = Color3.fromRGB(50, 180, 255)
line1.TextXAlignment = Enum.TextXAlignment.Left
line1.RichText = true

local line2 = Instance.new("TextLabel", statusFrame)
line2.Size = UDim2.new(1, -10, 0, 18)
line2.Position = UDim2.new(0, 5, 0, 23)
line2.BackgroundTransparency = 1
line2.Font = Enum.Font.GothamBold
line2.TextSize = 11
line2.TextColor3 = Color3.fromRGB(75, 175, 75)
line2.TextXAlignment = Enum.TextXAlignment.Left
line2.RichText = true

local line3 = Instance.new("TextLabel", statusFrame)
line3.Size = UDim2.new(1, -10, 0, 18)
line3.Position = UDim2.new(0, 5, 0, 41)
line3.BackgroundTransparency = 1
line3.Font = Enum.Font.GothamBold
line3.TextSize = 11
line3.TextColor3 = Color3.fromRGB(200, 50, 0)
line3.TextXAlignment = Enum.TextXAlignment.Left

-- Minimize
local toggleUI = Instance.new("TextButton", statusFrame)
toggleUI.Size = UDim2.new(0, 20, 0, 20)
toggleUI.Position = UDim2.new(1, -22, 1, -22)
toggleUI.BackgroundTransparency = 1
toggleUI.Text = "‚Üï"
toggleUI.TextColor3 = Color3.fromRGB(150, 150, 150)
toggleUI.Font = Enum.Font.GothamBold
toggleUI.TextSize = 18

local isMinimized = false
toggleUI.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    container.Visible = not isMinimized
    titleBar.Visible = not isMinimized
    if isMinimized then
        main.BackgroundTransparency = 1
        stroke.Transparency = 1
        main.Size = UDim2.new(0, 260, 0, 65)
        statusFrame.Position = UDim2.new(0, 8, 0, 0)
        statusFrame.Active = true
    else
        main.BackgroundTransparency = 0
        stroke.Transparency = 0
        main.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        main.Size = UDim2.new(0, 260, 0, 310)
        statusFrame.Position = UDim2.new(0, 8, 1, -68)
        statusFrame.Active = false
    end
end)

-- Dragging Logic
local function enableDragging(frame, dragFrame)
    local dragging, dragStart, startPos
    dragFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)
    dragFrame.InputEnded:Connect(function(input) 
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end 
    end)
    UIS.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end
enableDragging(main, titleBar)
enableDragging(main, statusFrame)

local function createReopen()
    local reopen = Instance.new("ImageButton", gui)
    reopen.Name = "Reopen"
    reopen.Image = "rbxassetid://6031280882"
    reopen.Size = UDim2.new(0, 35, 0, 35)
    reopen.Position = UDim2.new(0, 20, 0.5, 0)
    reopen.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Instance.new("UICorner", reopen).CornerRadius = UDim.new(0, 8)
    Instance.new("UIStroke", reopen).Color = Color3.fromRGB(60,60,60)
    reopen.MouseButton1Click:Connect(function() 
        main.Visible = true
        reopen:Destroy() 
    end)
end
close.MouseButton1Click:Connect(function() 
    main.Visible = false
    createReopen() 
end)

local function makeBtn(text, color, layoutOrder)
    local btn = Instance.new("TextButton", container)
    btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    btn.Font = Enum.Font.GothamMedium
    btn.TextSize = 11
    btn.TextColor3 = color or Color3.fromRGB(255, 60, 60)
    btn.Text = text
    btn.AutoButtonColor = false
    if layoutOrder then btn.LayoutOrder = layoutOrder end
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)
    local s = Instance.new("UIStroke", btn)
    s.Color = Color3.fromRGB(50, 50, 50)
    s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    btn.MouseEnter:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40) end)
    btn.MouseLeave:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(30, 30, 30) end)
    return btn
end

local function update(btn, var, label, cd)
    local on = Settings[var]
    local suffix = ""
    if cd and cd > 0 then suffix = " (" .. cd .. "s)" end
    btn.TextColor3 = on and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 80, 80)
    btn.Text = string.format("%s: %s%s", label, on and "ON" or "OFF", suffix)
end

-- Create Buttons
local autoRankBtn = makeBtn("Auto Rank", nil, 1)
local autoFarmBtn = makeBtn("Farm Dust", nil, 2)
local autoAuraBtn = makeBtn("Auto Aura", nil, 3) 
local autoEquipBtn = makeBtn("Auto Equip", nil, 4)
local autoHatchBtn = makeBtn("Auto Hatch", nil, 5)
local mapDrop = makeBtn(Settings.MapSelected, Color3.fromRGB(200, 200, 200), 6)
local autoRaidBtn = makeBtn("Auto Raid", nil, 7)
local raidConfigBtn = makeBtn("Raid Config", Color3.fromRGB(0, 200, 255), 8)
local WorldBossBtn = makeBtn("Boss Hunt", nil, 9)
local wbConfigDrop = makeBtn("Boss Config", Color3.fromRGB(255, 170, 0), 10)
local soloRaidBtn = makeBtn("Spam Raid", nil, 11) 
local soloRaidModeBtn = makeBtn(Settings.SoloRaidMode, Color3.fromRGB(200,200,200), 12) 
local dStatusBtn = makeBtn("Discord Status", Color3.fromRGB(255, 100, 100), 13)
local saveLocBtn = makeBtn("Save Point", Color3.fromRGB(255, 200, 50), 14)
local renderBtn = makeBtn("3D Render", nil, 15)
local eggFrameBtn = makeBtn("Egg Animation", Color3.fromRGB(50, 180, 255), 16)

update(autoRankBtn, "AutoRank", "Auto Rank")
update(autoAuraBtn, "AutoAura", "Auto Aura")
update(autoFarmBtn, "RuneSword", "Farm Dust")
update(autoEquipBtn, "AutoEquip", "Auto Equip")
update(autoRaidBtn, "AutoRaid", "Auto Raid")
update(autoHatchBtn, "AutoHatch", "Auto Hatch")
update(WorldBossBtn, "WorldBoss", "Boss Hunt")
update(soloRaidBtn, "SoloRaid", "Spam Raid")
update(renderBtn, "Rendering3D", "3D Render")
update(eggFrameBtn, "EggFrame", "Egg Animation")
update(dStatusBtn, "dStatus", "Discord Status")

-- Dropdown Logic
local activeDropdown
local function makeDropdown(parent, list, onSelect, isToggle, toggleSource, toggleSourceList)
    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 120, 0, math.min(#list * 22, 220))
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.Visible = false
    frame.ZIndex = 60
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 4)
    Instance.new("UIStroke", frame).Color = Color3.fromRGB(60,60,60)
    local scroll = Instance.new("ScrollingFrame", frame)
    scroll.Size = UDim2.new(1,0,1,0)
    scroll.BackgroundTransparency = 1
    scroll.ScrollBarThickness = 2
    scroll.ZIndex = 61
    local dLayout = Instance.new("UIListLayout", scroll)
    dLayout.SortOrder = Enum.SortOrder.LayoutOrder
    dLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() 
        scroll.CanvasSize = UDim2.new(0, 0, 0, dLayout.AbsoluteContentSize.Y) 
    end)

    -- Store references to all option buttons for toggle refresh
    local optionButtons = {}

    for _, item in ipairs(list) do
        local opt = Instance.new("TextButton", scroll)
        opt.Size = UDim2.new(1, 0, 0, 22)
        opt.BackgroundTransparency = 1
        opt.TextColor3 = Color3.fromRGB(200, 200, 200)
        opt.Font = Enum.Font.Gotham
        opt.TextSize = 11
        opt.Text = item
        opt.ZIndex = 62
        
        if isToggle then
            optionButtons[item] = opt
            
            local function refresh()
                local en = false
                if toggleSourceList then
                    -- For array-based tables (like wbossMaps) - check if ANY entry for this map is enabled
                    for _, data in ipairs(toggleSourceList) do
                        if data.map == item then
                            if data.enabled then
                                en = true
                                break
                            end
                        end
                    end
                else
                    -- For keyed tables (like RaidSettings)
                    en = toggleSource[item] and toggleSource[item].enabled
                end
                opt.TextColor3 = en and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
            end
            
            refresh()
            
            opt.MouseButton1Click:Connect(function()
                onSelect(item, function()
                    -- Refresh all options
                    for optionItem, optionBtn in pairs(optionButtons) do
                        local en = false
                        if toggleSourceList then
                            -- Check if ANY entry for this map is enabled
                            for _, data in ipairs(toggleSourceList) do
                                if data.map == optionItem then
                                    if data.enabled then
                                        en = true
                                        break
                                    end
                                end
                            end
                        else
                            en = toggleSource[optionItem] and toggleSource[optionItem].enabled
                        end
                        optionBtn.TextColor3 = en and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
                    end
                end)
            end)
        else
            opt.MouseButton1Click:Connect(function() 
                onSelect(item)
                frame.Visible = false
                activeDropdown = nil 
            end)
        end
    end

    parent.MouseButton1Click:Connect(function()
        if activeDropdown and activeDropdown ~= frame then activeDropdown.Visible = false end
        frame.Visible = not frame.Visible
        if frame.Visible then
            local abs = parent.AbsolutePosition
            frame.Position = UDim2.fromOffset(abs.X, abs.Y + 25)
            activeDropdown = frame
        else activeDropdown = nil end
    end)
end

makeDropdown(mapDrop, mapList, function(sel) 
    Settings.MapSelected = sel
    mapDrop.Text = sel
    SaveConfig() 
end, false)

makeDropdown(wbConfigDrop, OrderedBossNames, function(sel, upd) 
    local newState = nil
    for _, bossData in ipairs(wbossMaps) do
        if bossData.map == sel then
            if newState == nil then
                newState = not bossData.enabled
            end
            bossData.enabled = newState
        end
    end
    upd()
    SaveConfig()
end, true, wbossMaps, wbossMaps)

local sortedRaidKeys = {}
for k,v in pairs(RaidSettings) do table.insert(sortedRaidKeys, k) end
table.sort(sortedRaidKeys)

makeDropdown(raidConfigBtn, sortedRaidKeys, function(sel, upd) 
    if RaidSettings[sel] then 
        RaidSettings[sel].enabled = not RaidSettings[sel].enabled
        upd()
        SaveConfig() 
    end 
end, true, RaidSettings)

local modes = {"Easy", "Medium", "Hard", "Infinity", "Divinity", "Christmas", "Halloween"}
makeDropdown(soloRaidModeBtn, modes, function(sel) 
    Settings.SoloRaidMode = sel
    soloRaidModeBtn.Text = sel
    SaveConfig() 
end, false)

--// GAME LOGIC
local function saveMapandLocation()
    local char = player.Character
    if not char then return end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local client = Workspace:FindFirstChild("Client")
    local mapFolder = client and client:FindFirstChild("Maps")
    
    if mapFolder and #mapFolder:GetChildren() > 0 then
        local currentMap = mapFolder:GetChildren()[1]
        if root and currentMap and not string.find(string.lower(currentMap.Name), "raid") then
            pcall(function() 
                Settings.MapLocations[currentMap.Name] = serializeCFrame(root.CFrame) 
            end)
            SaveConfig()
            Notify("Maps Config", "Saved Location: " .. currentMap.Name)
        else 
            Notify("Maps Config", "Cannot Save: In Raid or Character missing.") 
        end
    end
end

local function removeCurrentMapLocation()
    local client = Workspace:FindFirstChild("Client")
    local mapFolder = client and client:FindFirstChild("Maps")
    
    if mapFolder and #mapFolder:GetChildren() > 0 then
        local currentMap = mapFolder:GetChildren()[1]
        if currentMap and Settings.MapLocations[currentMap.Name] then
            Settings.MapLocations[currentMap.Name] = nil
            SaveConfig()
            Notify("Maps Config", "Removed Location.")
        else 
            Notify("Maps Config", "No saved location found.") 
        end
    end
end

local function safeSetRootToSavedLocation(specificMap)
    task.wait(3)
    if State.inRaid or State.inAbuseRaid or State.extRaid or State.tpBoss then return end
    
    local char = player.Character or player.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart", 5)
    if not root then return false end
    
    local mapName = specificMap
    if not mapName then 
        local c = Workspace:FindFirstChild("Client")
        if c and c:FindFirstChild("Maps") and #c.Maps:GetChildren() > 0 then 
            mapName = c.Maps:GetChildren()[1].Name 
        end 
    end
    
    if mapName and Settings.MapLocations[mapName] then
        local loc = deserializeCFrame(Settings.MapLocations[mapName])
        if loc then
            pcall(function() 
                root.AssemblyLinearVelocity = Vector3.new(0,0,0)
                root.AssemblyAngularVelocity = Vector3.new(0,0,0)
                root.CFrame = loc
                root.Anchored = true
                task.delay(1.0, function() if root then root.Anchored = false end end) 
            end)
            return true
        end
    end
    return false
end

local function watchObject(obj)
    if not (obj:IsA("TextLabel") or obj:IsA("TextBox") or obj:IsA("TextButton")) then return end
    
    local lastCheck = 0
    local function check()
        if not obj.Visible then return end
        if tick() - lastCheck < 0.5 then return end
        lastCheck = tick()
        
        local txt = obj.Text
        if not txt then return end
        
        local lTxt = string.lower(txt)
        if string.find(lTxt, "you not enough souls") and Settings.AutoHatch then 
            if Settings.getSouls then 
                Settings.AutoHatch = false
                Scheduler.timers.AutoHatch.time = 900
                State.tpgetSouls = true 
                if Settings.AutoRaid then 
                    Settings.AutoRaid = false
                    update(autoRaidBtn, "AutoRaid", "Auto Raid")
                    task.delay(1800, function() 
                        Settings.AutoRaid = true 
                        update(autoRaidBtn, "AutoRaid", "Auto Raid")
                    end) 
                end
                if Settings.SoloRaid then 
                    Settings.SoloRaid = false
                    update(soloRaidBtn, "SoloRaid", "Spam Raid")
                    task.delay(1800, function() 
                        Settings.SoloRaid = true 
                        update(soloRaidBtn, "SoloRaid", "Spam Raid")
                    end) 
                end
                SendDiscord("‚ùå Auto Hatch Pause (30m): Not Enough Souls! Back to farming souls.")
                SaveConfig()
            elseif Settings.SoloRaid then
                Settings.AutoHatch = false
                Scheduler.timers.AutoHatch.time = nil
                update(autoHatchBtn, "AutoHatch", "Auto Hatch")
                SaveConfig()
            else
                Settings.AutoHatch = false
                Scheduler.timers.AutoHatch.time = 900
                update(autoHatchBtn, "AutoHatch", "Auto Hatch")
                SaveConfig()
            end
        elseif string.find(lTxt, "inventory is full") then 
            Settings.AutoHatch = false
            Scheduler.timers.AutoHatch.time = nil
            update(autoHatchBtn, "AutoHatch", "Auto Hatch")
            SendDiscord("‚ùå Auto Hatch Stop: Inventory Full!")
            SaveConfig() 
        end
    end
    
    AddConnection(obj:GetPropertyChangedSignal("Text"):Connect(check))
    AddConnection(obj:GetPropertyChangedSignal("Visible"):Connect(check))
end

for _, obj in ipairs(playerGui:GetDescendants()) do watchObject(obj) end
AddConnection(playerGui.DescendantAdded:Connect(function(obj) task.wait(); watchObject(obj) end))

local function splitsword()
    while task.wait(300) do
        if not Settings.RuneSword or not State.inLost then break end
        local c = Workspace:FindFirstChild("Client")
        if c and c:FindFirstChild("Maps") then
            local ch = c.Maps:GetChildren()
            if #ch > 0 and ch[1].Name == "Lost Temple" then 
                pcall(function() 
                    Bridge:FireServer("Wsplit", "Split", { CurrentSword = "Lost Rune", Amount = 35 }) 
                end) 
                break 
            end
        end
    end
end

local function handleMapAdded(mapModel)
    if not mapModel or not mapModel.Name then return end
    
    task.wait(1)
    local name = mapModel.Name
    local lowerName = string.lower(name)
    
    if string.find(lowerName, "raid") then
        State.inRaid = true
        State.raidMap = name
        State.RaidStartTimestamp = tick()
        State.tpBoss = false
        State.RaidCount = State.RaidCount + 1
        
        -- Increment Stats
        Settings.RaidStats.Today = Settings.RaidStats.Today + 1
        Settings.RaidStats.Month = Settings.RaidStats.Month + 1
        SaveConfig()
                
        if mapModel.Name == "Raid_Abuse" then 
            State.inAbuseRaid = true 
            if Settings.WorldBoss then 
                Settings.WorldBoss = false
                task.delay(1800, function() Settings.WorldBoss = true end)
            end    
        end
        
        if State.tpBoss or State.wbSpawn then
            State.tpBoss = false
            State.wbSpawn = false
            State.mapToReturn = State.MapSelected
            if State.BossConnections then 
                for _, c in pairs(State.BossConnections) do c:Disconnect() end 
            end
            SendDiscord("‚ùå Boss Hunt: " .. wbtype .. " at " .. wbSpawnMapName .. "Cancelled | Joined Raid **" .. name .. "**")
        else
            SendDiscord("‚öîÔ∏è Auto Raid: Joining **" .. name .. "** (**x" .. State.RaidCount .. "**)")
        end

        if Settings.AutoHatch and not Settings.dCareppl then
            Settings.AutoHatch = false
            Scheduler.timers.AutoHatch.time = 900
            if name == "Raid_Abuse" or name == "Raid_Christmas" then 
                Scheduler.timers.AutoHatch.time = 1800 
            end
        end
    --elseif Settings.WorldBoss and State.tpBoss then
    --    task.delay(720, function()
    --        if State.tpBoss and not State.wbSpawn then
    --            State.tpBoss = false
    --            Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
    --            SendDiscord("üåã Boss **" .. name .. "** Spawn Timeout. Returning to **" .. Settings.MapSelected .. "**")
    --            -- Clean Boss connections (local management)
    --            if State.BossConnections then 
    --                for _, c in pairs(State.BossConnections) do c:Disconnect() end 
    --            end
    --        end
    --    end)
    elseif State.extRaid then
        return
    elseif name == "Lost Temple" and Settings.RuneSword then
        State.inLost = true
        task.wait(3)
        local lp = Players.LocalPlayer
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            lp.Character.HumanoidRootPart.CFrame = CFrame.new(Vector3.new(319.670, 111.599, 4088.302))
            SendDiscord("üåÄ Teleporting to **Ultra Boss** Location at **Lost Temple**")
            task.wait(10)
            task.spawn(function() splitsword() end)
        end
    elseif Settings.SoloRaid then
        State.extRaid = true
        task.delay(10, function() State.extRaid = false end)
    elseif not Settings.SoloRaid and not State.inRaid and not State.tpBoss and not State.extRaid then 
        task.wait(2)
        if safeSetRootToSavedLocation(name) then 
            SendDiscord("üìç Teleporting to Saved Location at **" .. name .. "**")
            State.mapToReturn = nil
            State.wbSpawn = false
            State.tpBoss = false
        end      
    end
end

local function handleMapRemoved(mapModel)
    if not mapModel or not mapModel.Name then return end
    
    local oldMap = mapModel.Name
 
    if string.find(string.lower(oldMap), "raid") then
        State.inRaid = false
        State.raidMap = nil
        State.tpBoss = false
        State.wbSpawn = false
        State.LastRaidFinish = tick()
        
        if mapModel.Name == "Raid_Abuse" then State.inAbuseRaid = false end
        
        local nextRaid = getNextRaidData()
        local nextRaidMsg = "None Raid Selected"
        if nextRaid and Settings.AutoRaid then
            nextRaidMsg = string.format("%s in %s", nextRaid.name, formatSeconds(nextRaid.seconds))
        end
        
        local dcraidmsg = "üí• Auto Raid: Left **" .. oldMap .. "** "
        if State.RaidStartTimestamp then
            local raidDuration = tick() - State.RaidStartTimestamp
            dcraidmsg = string.format("üí• Auto Raid: Left **" .. oldMap .. "**. ‚è±Ô∏è Raid Duration: %s ", formatSeconds(raidDuration)) 
        end

        if Settings.AutoRaid then
            dcraidmsg = dcraidmsg .. " Next Raid : **" .. nextRaidMsg .. "**"
        end
        SendDiscord(dcraidmsg)
        
        if Scheduler.timers.AutoHatch.time and Scheduler.timers.AutoHatch.time > 10 then
            Settings.AutoHatch = true
            Scheduler.timers.AutoHatch.time = nil
            update(autoHatchBtn, "AutoHatch", "Auto Hatch")
        end
    elseif oldMap == "Lost Temple" then 
        State.inLost = false 
    end
end

task.spawn(function()
    local client = Workspace:WaitForChild("Client", 15)
    if client then
        local mapsFolder = client:WaitForChild("Maps", 15)
        if mapsFolder then
            AddConnection(mapsFolder.ChildAdded:Connect(handleMapAdded))
            AddConnection(mapsFolder.ChildRemoved:Connect(handleMapRemoved))
            if #mapsFolder:GetChildren() > 0 then handleMapAdded(mapsFolder:GetChildren()[1]) end
        end
    end
end)

local function collectDailyStuff()
    task.spawn(function()
        pcall(function()
            if not Settings.ClaimedToday then
                Bridge:FireServer("DailyChestsServer", "OpenChest", "CommonChest")
                task.wait(1)
                Bridge:FireServer("DailyChestsServer", "OpenChest", "GroupChest")
                task.wait(1)
                Bridge:FireServer("DailyChestsServer", "OpenChest", "VIPChest")
                task.wait(1)
                Engagement:FireServer({event = "ClaimAll", type = "Daily"})
                Engagement:FireServer({event = "GetStats"})
                Settings.ClaimedToday = true
                SaveConfig()
            end
            Engagement:FireServer({event = "ClaimAll", type = "Time"})
        end)
    end)
end

--- // Raid Logic
local raidDebounce = false
local function JoinRaid(raidName)
    if raidDebounce or State.inAbuseRaid then return end

    raidDebounce = true
    if State.inRaid and State.raidMap ~= "Raid_Abuse" and raidName == "Raid_Abuse" then
        Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Leave", Args = State.raidMap })
        SendDiscord("ü™ô Exiting **" .. State.raidMap .. "** to join **" .. raidName .. "**")
        State.extRaid = true
        task.delay(10, function() State.extRaid = false end)
        task.wait(3)
    end
    
    if State.inRaid and State.raidMap ~= "Raid_DemonSlayer" and raidName == "Raid_DemonSlayer" then
        Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Leave", Args = State.raidMap })
        SendDiscord("üëπ Exiting **" .. State.raidMap .. "** to join **" .. raidName .. "**")
        State.extRaid = true
        task.delay(10, function() State.extRaid = false end)
        task.wait(3)
    end
    
    if State.inRaid then return end
    
    if table.find(NewRaidMaps, raidName) then 
        Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Join", Args = raidName })
        task.wait(10)
    else 
        Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Start", Args = raidName })
        task.wait(10) 
    end
    
    task.wait(1)
    raidDebounce = false
end

--- // World Boss Logic
local function worldbossraid(wbSpawnMapName, wbSpawnMapPos, wbtype)
    if State.inAbuseRaid then return end
    
    -- If already fighting a boss, queue this one for later
    if State.tpBoss then
        State.BossQueue = {
            map = wbSpawnMapName,
            pos = wbSpawnMapPos,
            type = wbtype
        }
        SendDiscord("‚è≥ Boss Queued: **" .. wbSpawnMapName .. "** (" .. wbtype .. ") will trigger after current boss")
        return
    end
    
    if wbSpawnMapName and not State.tpBoss then
        pcall(function()
            if State.inRaid and State.raidMap ~= "Raid_Abuse" then
                Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Leave", Args = State.raidMap })
                SendDiscord("üêâ Exiting **" .. State.raidMap .. "** for Hunt **" .. wbSpawnMapName .. "** " .. wbtype)
                State.extRaid = true
                task.delay(10, function() State.extRaid = false end)
                task.wait(3)
            end
            State.tpBoss = true
            local mapsF = Workspace:FindFirstChild("Client"):FindFirstChild("Maps")
            if mapsF and #mapsF:GetChildren() > 0 then
                local currentMapName = mapsF:GetChildren()[1].Name
                if not string.find(string.lower(currentMapName), "raid") then 
                    State.mapToReturn = currentMapName
                else
                    State.mapToReturn = Settings.MapSelected 
                end
            end
            if State.mapToReturn == nil then State.mapToReturn = Settings.MapSelected end
            
            Bridge:FireServer("Teleport", "Spawn", wbSpawnMapName)
            State.tpBoss = true
            task.delay(900, function()
                if State.tpBoss then
                    State.tpBoss = false
                    if State.BossConnections then 
                        for _, c in pairs(State.BossConnections) do c:Disconnect() end 
                    end
                end
            end)
            task.wait(3)
            State.tpWBossAltar = math.random(30, 45)
            
            local lp = Players.LocalPlayer
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                State.tpBoss = true
                lp.Character.HumanoidRootPart.CFrame = CFrame.new(wbSpawnMapPos)
                SendDiscord("üåÄ Teleporting to " .. wbtype .. " Altar at **" .. wbSpawnMapName .. "**")
                task.delay(200, function()
                    if State.tpBoss and not State.wbSpawn then 
                        State.tpBoss = false
                        Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
                        SendDiscord("‚è±Ô∏è " .. wbtype .. " Spawn Timeout at **" .. wbSpawnMapName .. "** | üåÄ Returning to **" .. Settings.MapSelected .. "**")
                        if State.BossConnections then 
                            for _, c in pairs(State.BossConnections) do c:Disconnect() end 
                        end
                    end
                end)
            end
            
            local client = Workspace:WaitForChild("Client", 30)
            local enemies = client and client:WaitForChild("Enemies", 30)
            local bossFolder = enemies and enemies:WaitForChild("WorldBoss", 30)
            
            if not bossFolder then 
                State.tpBoss = false
                return 
            end
            
            if State.BossConnections then 
                for _, c in pairs(State.BossConnections) do c:Disconnect() end 
            end
            State.BossConnections = {}

            local c1 = bossFolder.ChildAdded:Connect(function(child) 
                State.wbSpawn = true
                if wbtype == "World Boss" then
                    SendDiscord("üíÄ " .. wbtype .. " **" .. wbSpawnMapName .. "** Spawned")
                    task.delay(315, function() 
                        if State.wbSpawn then 
                            State.tpBoss = false 
                        end 
                    end)
                elseif wbtype == "Divine Angel" then
                    SendDiscord("ü™Ω " .. wbtype .. " **" .. wbSpawnMapName .. "** Spawned")
                    task.delay(615, function() 
                        if State.wbSpawn then 
                            State.tpBoss = false 
                        end 
                    end)
                end
            end)
            table.insert(State.BossConnections, c1)

            local c2 = bossFolder.ChildRemoved:Connect(function(child)
                for _, c in pairs(State.BossConnections) do c:Disconnect() end
                State.BossConnections = {}
                task.wait(5)
                
                State.tpBoss = false
                State.wbSpawn = false
                State.WBCount = State.WBCount + 1
                
                -- Increment WB Stats
                Settings.WBStats.Today = Settings.WBStats.Today + 1
                Settings.WBStats.Month = Settings.WBStats.Month + 1
                SaveConfig()

                State.tpWBossAltar = math.random(30, 45)
                local nb = getNextBossData()
                nextBossMsg = nb and string.format("**Next:** %s at %s in %s", nb.type, nb.map, formatSeconds(nb.diffSeconds)) or "None Boss Selected"
                
                local hasQueuedBoss = State.BossQueue ~= nil
                
                if Settings.SoloRaid then
                    SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated. Continue Raiding : **" .. Settings.SoloRaidMode .. "** | " .. nextBossMsg)
                    State.tpBoss = false
                elseif hasQueuedBoss then
                    local queuedBoss = State.BossQueue
                    State.BossQueue = nil
                    SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated. Triggering Queued Boss: **" .. queuedBoss.map .. "** (" .. queuedBoss.type .. ")")
                    State.tpBoss = false
                    task.wait(2)
                    task.spawn(function()
                        worldbossraid(queuedBoss.map, queuedBoss.pos, queuedBoss.type)
                    end)
                else
                    State.tpBoss = false
                    if State.mapToReturn then
                        if wbSpawnMapName == State.mapToReturn then 
                            if safeSetRootToSavedLocation(wbSpawnMapName) then 
                                SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated.üìç Teleporting to Saved Location at **" .. wbSpawnMapName .. "**")
                            else
                                Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
                                SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated. üåÄ Return to **" .. Settings.MapSelected .. "** | " .. nextBossMsg)
                            end 
                        else
                            Bridge:FireServer("Teleport", "Spawn", State.mapToReturn)
                            SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated. üåÄ Return to **" .. State.mapToReturn .. "** | " .. nextBossMsg)
                        end
                    else
                        Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
                        SendDiscord("‚öîÔ∏è " .. wbtype .. " **" .. wbSpawnMapName .. "** Defeated. üåÄ Return to **" .. Settings.MapSelected .. "** | " .. nextBossMsg)
                    end
                end
            end)
            table.insert(State.BossConnections, c2)
            
            if #bossFolder:GetChildren() > 0 then State.wbSpawn = true end
        end)
    end
end

-- // MAIN LOOP
task.spawn(function()
    while task.wait(1) do
        -- Timers
        -- Rank
        local tRank = getTimer("AutoRank")
        if Settings.AutoRank and tRank.time <= 0 then
            tRank.time = tRank.delay
            pcall(function()
                local rnk, uiPricerNum = pcall(function() return playerGui.UI.Frames.RankUp.NewMain.viewInside.backCollect.amount.Text end)
                if rnk and uiPricerNum then
                    local getPricerNum = string.gsub(uiPricerNum, " to new rank", "")
                    local priceRWrd = tostring(getPricerNum:match("%a+"))
                    local priceRNum = tonumber(getPricerNum:match("[%d%.]+"))

                    local lp = game:GetService("Players").LocalPlayer
                    if lp:FindFirstChild("leaderstats") and lp.leaderstats:FindFirstChild("Power") then getPowersNum = lp.leaderstats.Power.Value end
                    local powerRWrd = tostring(getPowersNum:match("%a+"))
                    local powerRNum = tonumber(getPowersNum:match("[%d%.]+"))

                    if priceRWrd and powerRWrd and powerRWrd == priceRWrd then
                        if powerRNum >= priceRNum then
                            Bridge:FireServer("RankUp", "Evolve")
                            task.wait(2)
                            local success, uiRanktitle = pcall(function() return playerGui.UI.Frames.RankUp.NewMain.viewInside.levelViews.currentView.levelInfo.title.Text end)
                            if not success then uiRanktitle = "N/A" end
                            SendDiscord("üÜô **Rank Up!** Reached Rank : **" .. tostring(uiRanktitle) .. "**. (AutoRank Pause for 30 Minute) SoloRaid ON (" .. Settings.SoloRaidMode .. ") while waiting POWER UP!!")
                            --Settings.AutoRank = false
                            --update(autoRankBtn, "AutoRank", "Auto Rank")
                            --task.delay(3600, function() Settings.AutoRank = true end)
                            --if Settings.AutoHatch then
                            --    Settings.AutoHatch = false
                            --update(autoHatchBtn, "AutoHatch", "Auto Hatch")
                            --SaveConfig()
                            --end
                            --if not Settings.AutoRaid and not Settings.SoloRaid then 
                            --    Settings.SoloRaid = true
                            --update(soloRaidBtn, "SoloRaid", "Spam Raid")
                            --    SendDiscord("‚öîÔ∏è Spam Raid Enabled after Rank Up : **" .. Settings.SoloRaidMode .. "**")
                            --end
                            SaveConfig()
                        end
                    end
                end
            end)
        else
            tRank.time = tRank.time - 1
            --update(autoRankBtn, "AutoRank", "Auto Rank", tRank.time)
        end

        -- Aura
        local tAura = getTimer("AutoAura")
        if Settings.AutoAura and tAura.time <= 0 then
            tAura.time = tAura.delay
            pcall(function()
                local success, uiNextAura = pcall(function() return playerGui.UI.Frames.Auras.Main.Frame.Next.AuraName.Text end)
                if uiNextAura == "MAX" then
                    Settings.AutoAura = false
                    update(autoAuraBtn, "AutoAura", "Aura MAX so")
                    SaveConfig()
                else
                    local anr, uiPriceaNum = pcall(function() return playerGui.UI.Frames.Auras.Main.Frame.Amount.Text end)
                    if anr and uiPriceaNum then
                        local getPriceaNum = tostring(uiPriceaNum)
                        local priceAWrd = tostring(getPriceaNum:match("%a+"))
                        local priceANum = tonumber(getPriceaNum:match("[%d%.]+"))

                        local lp = game:GetService("Players").LocalPlayer
                        if lp:FindFirstChild("leaderstats") and lp.leaderstats:FindFirstChild("Souls") then getSoulsNum = lp.leaderstats.Souls.Value end
                        local soulsAWrd = tostring(getSoulsNum:match("%a+"))
                        local soulsANum = tonumber(getSoulsNum:match("[%d%.]+"))

                        if priceAWrd and soulsAWrd and soulsAWrd == priceAWrd then
                            if soulsANum >= priceANum then
                                Bridge:FireServer("Auras", "Evolve")
                                SendDiscord("‚ú® **Aura Evolved!** Reached Aura : **" .. tostring(uiNextAura) .. "**")
                                if Settings.AutoHatch then
                                    Settings.AutoHatch = false
                                    local tH = getTimer("AutoHatch")
                                    if tH then tH.time = 1800 end
                                end
                                SaveConfig()
                            end
                        end
                    end
                end
            end)
        else
            tAura.time = tAura.time - 1
        end

        -- Equip        
        local tEquip = getTimer("AutoEquip")
        if Settings.AutoEquip then
            if tEquip.time <= 0 then 
                tEquip.time = tEquip.delay
                pcall(function() Bridge:FireServer("Pets", "Best") end) 
            else 
                tEquip.time = tEquip.time - 1 
            end
            update(autoEquipBtn, "AutoEquip", "Auto Equip", tEquip.time)
        end
        -- Hatch
        local tHatch = getTimer("AutoHatch")
        if Settings.AutoHatch and Settings.MapSelected then 
            pcall(function() Bridge:FireServer("Stars", "Roll", { Map = Settings.MapSelected, Type = "Multi" }) end)
        elseif tHatch.time then 
            tHatch.time = tHatch.time - 1
            if tHatch.time <= 0 then 
                Settings.AutoHatch = true
                tHatch.time = nil
                update(autoHatchBtn, "AutoHatch", "Auto Hatch") 
            end
            update(autoHatchBtn, "AutoHatch", "Auto Hatch", tHatch.time) 
        end
        -- Lost Temple Rune Sword
        if Settings.RuneSword and not State.inRaid and not State.inLost and not State.tpBoss then 
            Bridge:FireServer("Teleport", "Spawn", "Lost Temple") 
        end
        
        -- CHECK RESET DAILY
        CheckDailyReset()

        -- Status Updates
        local ping = StatsService.Network.ServerStatsItem["Data Ping"]:GetValueString()
        local pingNum = tonumber(ping:match("%d+")) or 0
        local fps = Workspace:GetRealPhysicsFPS()
        local memGB = StatsService:GetTotalMemoryUsageMb() / 1024
        
        -- Line 1
        local ClockColor = "#FFAA00"
        local pingColor = "#64FF64"
        if pingNum > 90 then pingColor = "#FF5050" elseif pingNum > 60 then pingColor = "#FFAA00" end
        
        if Settings.AutoRaid or Settings.SoloRaid then
            line1.Text = string.format("<font color='%s'>Ping: %dms</font> | FPS: %d | <font color='%s'>%s</font> | Raid: x%d", pingColor, pingNum, fps, ClockColor, os.date("%H:%M:%S"), State.RaidCount)
        else
            line1.Text = string.format("<font color='%s'>Ping: %dms</font> | FPS: %d | <font color='%s'>%s</font>", pingColor, pingNum, fps, ClockColor, os.date("%H:%M:%S"))
        end
        
        -- Line 2
        local memColor = "#64FF64"
        if memGB > 8 then memColor = "#FF5050" elseif memGB > 3 then memColor = "#FFAA00" end
        line2.Text = string.format("<font color='%s'>Memory: %.2fGB</font> | Runtime: %s", memColor, memGB, getRuntime())

        -- Line 3
        local nextBoss = nil
        if Settings.WorldBoss then nextBoss = getNextBossData() end

        local nextRaid = nil
        if Settings.AutoRaid then nextRaid = getNextRaidData() end

        local wbSeconds = 999999
        if nextBoss then wbSeconds = nextBoss.diffSeconds end

        local raidSeconds = 999999
        if nextRaid and nextRaid.name ~= "None" then raidSeconds = nextRaid.seconds end

        if wbSeconds == 999999 and raidSeconds == 999999 then
            line3.Text = "Status: Idle"
            if Settings.SoloRaid then
                line3.Text = "Spam Raid Mode: " .. (SoloRaidModesMap[Settings.SoloRaidMode] or "N/A")
            end 
        elseif wbSeconds <= raidSeconds then
            line3.Text = string.format("%s at %s in %s", nextBoss.type, nextBoss.map, formatSeconds(wbSeconds))
        else
            line3.Text = string.format("Next Raid: %s in %s", nextRaid.name, formatSeconds(raidSeconds))
        end

        -- Discord Status Update
        if Settings.dStatus then
            if tick() - State.LastDiscordStatus >= math.random(3000, 3600) and os.date("*t").min % 15 ~= 0 then
                State.LastDiscordStatus = tick()
                local currentMapName = "Unknown"
                if State.raidMap then 
                    currentMapName = State.raidMap
                else
                    local mapsF = Workspace:FindFirstChild("Client") and Workspace.Client:FindFirstChild("Maps")
                    if mapsF and #mapsF:GetChildren() > 0 then currentMapName = mapsF:GetChildren()[1].Name end
                end
                
                local nextBossMsg = "**World Boss/Divine Angel Tracking**: OFF"
                if Settings.WorldBoss then 
                    local nb = getNextBossData()
                    nextBossMsg = nb and string.format("**Next %s:** %s in %s", nb.type, nb.map, formatSeconds(nb.diffSeconds)) or "None Boss Selected"
                end
                
                local nextRaidMsg = "Auto Raid: OFF"
                if Settings.AutoRaid then 
                    local nr = getNextRaidData()
                    nextRaidMsg = nr and string.format("**Next Raid:** %s in %s", nr.name, formatSeconds(nr.seconds)) or "None Raid Selected"
                end
                if Settings.SoloRaid then
                    nextRaidMsg = "**Spam Raid Mode:** " .. (SoloRaidModesMap[Settings.SoloRaidMode] or "N/A")
                end

                local lp = game:GetService("Players").LocalPlayer
                local pPower = "N/A"
                local pSouls = "N/A"
                local pEvo = "N/A"
                
                if lp:FindFirstChild("leaderstats") then
                    if lp.leaderstats:FindFirstChild("Power") then pPower = tostring(lp.leaderstats.Power.Value) end
                    if lp.leaderstats:FindFirstChild("Souls") then pSouls = tostring(lp.leaderstats.Souls.Value) end
                    if lp.leaderstats:FindFirstChild("Evolution") then pEvo = tostring(lp.leaderstats.Evolution.Value) end
                end
                
                local nRankPrice = "MAX"
                local nAuraPrice = "MAX"
                
                local success, uiRanktitle = pcall(function() return playerGui.UI.Frames.RankUp.NewMain.viewInside.levelViews.currentView.levelInfo.title.Text end)
                if not success then uiRanktitle = "N/A" end

                local success2, uiCurrAura = pcall(function() return playerGui.UI.Frames.Auras.Main.Frame.Current.AuraName.Text end)
                if not success2 then uiCurrAura = "N/A" end

                local success3, uiaPrice = pcall(function() return playerGui.UI.Frames.Auras.Main.Frame.Amount.Text end)
                if success3 and uiaPrice and not string.find(string.lower(uiaPrice), "highest") then nAuraPrice = uiaPrice end

                local success4, uirPrice = pcall(function() return playerGui.UI.Frames.RankUp.NewMain.viewInside.backCollect.amount.Text end)
                if success4 and uirPrice then nRankPrice = string.gsub(uirPrice, " to new rank", "") end

                -- Formatted Stats Strings
                local raidStatsStr = string.format("Session : %d | Today : %d | Month : %d", State.RaidCount, Settings.RaidStats.Today, Settings.RaidStats.Month)
                local wbStatsStr = string.format("Session : %d | Today : %d | Month : %d", State.WBCount, Settings.WBStats.Today, Settings.WBStats.Month)

                local embed = {
                    ["title"] = "‚öîÔ∏è AEVO Status üìä",
                    ["color"] = tonumber(0x4287f5),
                    ["fields"] = {
                        { ["name"] = "üë§ Player Stats", ["value"] = string.format("**Power:** %s\n**Souls:** %s\n**Evolution:** %s\n**Rank:** %s\n**Auras:** %s\n**Next Rank:** %s \n**Next Aura:** %s ", pPower, pSouls, pEvo, uiRanktitle, uiCurrAura, nRankPrice, nAuraPrice), ["inline"] = true },
                        { ["name"] = "‚öôÔ∏è System", ["value"] = string.format("**Ping:** %dms\n**FPS:** %d\n**Memory:** %.2fGB\n**Runtime:** %s", pingNum, fps, memGB, getRuntime()), ["inline"] = true },
                        { ["name"] = "üìç Location", ["value"] = string.format("**Map:** %s", currentMapName), ["inline"] = true },
                        { ["name"] = "‚è≥ Events", ["value"] = string.format("%s\n**Raid Count:** %s\n%s\n**Boss Defeated:** %s", nextRaidMsg, raidStatsStr, nextBossMsg, wbStatsStr), ["inline"] = false }
                    },
                    ["footer"] = { ["text"] = displayName .. " (@" .. username .. ") | " .. os.date("%H:%M:%S") }
                }
                SendDiscord(embed, true)
            end
        end

        local t = os.date("!*t")
        -- Triggers
        if Settings.WorldBoss and not State.tpBoss then
            for _, wd in ipairs(wbossMaps) do
                if wd.enabled and not State.tpBoss then
                    for _, ts in pairs(wd.time) do
                        local h, m = ts:match("(%d+):(%d+)")
                        h, m = tonumber(h), tonumber(m)
                        
                        if h and m then
                            local tM = m - 1
                            local tH = h
                            
                            if tM < 0 then 
                                tM = 59 
                                tH = tH - 1 
                            end
                            
                            if tH < 0 then tH = 23 end
                            
                            local rnd = State.tpWBossAltar or 30
                            
                            if t.hour == tH and t.min == tM and t.sec >= rnd and t.sec < (rnd + 5) then 
                                task.spawn(function() 
                                    worldbossraid(wd.map, wd.pos, wd.type) 
                                end)
                                break -- Break inner time loop
                            end
                        end
                    end
                end
                if State.tpBoss then break end -- Break outer map loop
            end
        end

        -- Raid Timeout Check
        if Settings.rtimeOut and not State.inAbuseRaid and State.inRaid and State.RaidStartTimestamp > 0 then
            local mapName = SoloRaidModesMap[Settings.SoloRaidMode]
            local timeElapsed = tick() - State.RaidStartTimestamp
   
            local isDivinity = (mapName == "Raid_Divinity")
            local timeout = isDivinity and 3600 or 1800 
            local logTime = isDivinity and "1H" or "30m"

            if mapName and mapName == State.raidMap and timeElapsed > timeout then
                Bridge:FireServer("Enemies", "Bridge", { Module = "RaidSystemServer", FunctionName = "Leave", Args = State.raidMap }) 
                SendDiscord("‚è≥ Event Raid Timeout (".. logTime .."). Force Leaving Raid.. " .. (State.raidMap or "Unknown"))
       
                State.inRaid = false
                State.RaidStartTimestamp = 0
                State.LastRaidFinish = tick()
            end
        end

        if t.sec > 1 and t.sec < 5 then
            -- Abuse Raid (UTC)
            if (t.hour == 3 or t.hour == 9 or t.hour == 15 or t.hour == 21) and t.min < 28 then -- Changed from 11, 23 (GMT+8)
                if not State.inAbuseRaid then 
                    task.spawn(function() JoinRaid("Raid_Abuse") end) 
                end
            -- Auto Raid
            elseif Settings.AutoRaid and not State.inAbuseRaid and not State.tpBoss then
                if t.min == 0 and RaidSettings["DemonSlayer"].enabled then 
                    task.spawn(function() JoinRaid("Raid_DemonSlayer") end)
                elseif t.min == 45 and RaidSettings["Insane"].enabled then 
                    task.spawn(function() JoinRaid("Raid_Insane") end)
                elseif t.min == 30 and RaidSettings["Crazy"].enabled then 
                    task.spawn(function() JoinRaid("Raid_Crazy") end)
                elseif t.min == 15 and RaidSettings["Crystal"].enabled then 
                    task.spawn(function() JoinRaid("Raid_Crystal") end)
                end
            -- Solo Raid
            elseif Settings.SoloRaid and not State.inRaid and not State.tpBoss and tick() - State.LastRaidFinish >= math.random(35,55) then
                local mapName = SoloRaidModesMap[Settings.SoloRaidMode or "Divinity"]
                if mapName then task.spawn(function() JoinRaid(mapName) end) end

            -- Return to Farm Map
            elseif Settings.getSouls and State.tpgetSouls and not Settings.AutoRaid and not Settings.SoloRaid and not State.inRaid and not State.tpBoss and not Settings.AutoHatch then
                local c = Workspace:FindFirstChild("Client")
                local mf = c and c:FindFirstChild("Maps")
                local cm = mf and #mf:GetChildren() > 0 and mf:GetChildren()[1]
                if cm and cm.Name ~= Settings.MapSelected then 
                    Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
                    SendDiscord("üè† Returning to **" .. Settings.MapSelected .. "**. Farming Soul for Hatching...")
                else 
                    safeSetRootToSavedLocation(cm.Name)
                end
                State.tpgetSouls = false
            end
            
            if t.hour >= 0 and t.min == 3 then collectDailyStuff() end
            if t.min % 10 == 0 then Engagement:FireServer({event = "ClaimAll", type = "Time"}) end
        end
    end
end)

-- Button Connects
autoRankBtn.MouseButton1Click:Connect(function() 
    Settings.AutoRank = not Settings.AutoRank
    if not Settings.AutoRank then Scheduler.timers.AutoRank.time = 0 end
    update(autoRankBtn, "AutoRank", "Auto Rank")
    SaveConfig() 
end)

autoAuraBtn.MouseButton1Click:Connect(function() 
    Settings.AutoAura = not Settings.AutoAura
    if not Settings.AutoAura then Scheduler.timers.AutoAura.time = 0 end
    update(autoAuraBtn, "AutoAura", "Auto Aura")
    SaveConfig() 
end)

autoEquipBtn.MouseButton1Click:Connect(function() 
    Settings.AutoEquip = not Settings.AutoEquip
    if not Settings.AutoEquip then Scheduler.timers.AutoEquip.time = 0 end
    update(autoEquipBtn, "AutoEquip", "Auto Equip")
    SaveConfig() 
end)

autoFarmBtn.MouseButton1Click:Connect(function() 
    Settings.RuneSword = not Settings.RuneSword
    update(autoFarmBtn, "RuneSword", "Farm Dust")
    Notify("Farm Dust", "Farm Ultra Boss World 3 : " .. (Settings.RuneSword and "ON" or "OFF"))
    if Settings.SoloRaid then
        Settings.SoloRaid = false
        update(soloRaidBtn, "SoloRaid", "Spam Raid") 
    end
    SaveConfig() 
end)

renderBtn.MouseButton1Click:Connect(function() 
    Settings.Rendering3D = not Settings.Rendering3D
    RunService:Set3dRenderingEnabled(Settings.Rendering3D)
    update(renderBtn, "Rendering3D", "3D Render")
    SaveConfig() 
end)

WorldBossBtn.MouseButton1Click:Connect(function() 
    Settings.WorldBoss = not Settings.WorldBoss
    if Settings.WorldBoss then State.tpBoss = false end
    update(WorldBossBtn, "WorldBoss", "Boss Hunt")
    if Settings.WorldBoss then
        if Settings.SoloRaid then
            Settings.SoloRaid = false
            update(soloRaidBtn, "SoloRaid", "Spam Raid") 
        end
        if Settings.AutoRaid then 
            Settings.AutoRaid = false
            update(autoRaidBtn, "AutoRaid", "Auto Raid") 
        end
        if Settings.RuneSword then
            Settings.RuneSword = false
            update(autoFarmBtn, "RuneSword", "Farm Dust")
        end
    end
    SaveConfig() 
end)

WorldBossBtn.MouseButton2Click:Connect(function() 
    Settings.getSouls = not Settings.getSouls
    Notify("Soul Farm", "Auto Soul Farm : " .. (Settings.getSouls and "ON" or "OFF"))
    SaveConfig() 
end)

autoRaidBtn.MouseButton1Click:Connect(function() 
    Settings.AutoRaid = not Settings.AutoRaid
    if Settings.AutoRaid then 
        Settings.SoloRaid = false
        update(soloRaidBtn, "SoloRaid", "Spam Raid") 
    end
    update(autoRaidBtn, "AutoRaid", "Auto Raid")
    SaveConfig() 
end)

soloRaidBtn.MouseButton1Click:Connect(function() 
    Settings.SoloRaid = not Settings.SoloRaid
    if Settings.SoloRaid then 
        Settings.AutoRaid = false
        update(autoRaidBtn, "AutoRaid", "Auto Raid") 
        Settings.RuneSword = false
        update(autoFarmBtn, "RuneSword", "Farm Dust")
    end
    update(soloRaidBtn, "SoloRaid", "Spam Raid")
    SaveConfig() 
end)

soloRaidBtn.MouseButton2Click:Connect(function() 
    Settings.rtimeOut = not Settings.rtimeOut
    Notify("Spam Raid", "Raid Timeout : " .. (Settings.rtimeOut and "ON" or "OFF"))
    SaveConfig() 
end)

autoHatchBtn.MouseButton1Click:Connect(function() 
    Settings.AutoHatch = not Settings.AutoHatch
    if Settings.AutoHatch then Scheduler.timers.AutoHatch.time = nil end
    update(autoHatchBtn, "AutoHatch", "Auto Hatch")
    SaveConfig() 
end)

autoHatchBtn.MouseButton2Click:Connect(function() 
    Settings.dCareppl = not Settings.dCareppl
    Notify("Auto Hatch", "dCareppl : " .. (Settings.dCareppl and "ON" or "OFF")) 
end)

dStatusBtn.MouseButton1Click:Connect(function() 
    Settings.dStatus = not Settings.dStatus
    update(dStatusBtn, "dStatus", "Discord Status")
    if Settings.dStatus and (Webhook == "" or Webhook == nil) then
        Settings.dStatus = false
        Notify("Discord Status", "Set Discord getgenv().Webhook URL First in Executor!")
        update(dStatusBtn, "dStatus", "NO Webhook so")
    end
    SaveConfig() 
end)

dStatusBtn.MouseButton2Click:Connect(function() 
    State.inRaid = false
    State.inAbuseRaid = false
    State.inLost = false
    State.tpBoss = false
    State.wbSpawn = false
    State.extRaid = false
    State.tpgetSouls = false
    State.mapToReturn = nil
    if State.BossConnections then 
        for _, c in pairs(State.BossConnections) do c:Disconnect() end 
    end
    Notify("State", "Reset Status") 
end)

saveLocBtn.MouseButton1Click:Connect(function() saveMapandLocation() end)
saveLocBtn.MouseButton2Click:Connect(function() removeCurrentMapLocation() end)

eggFrameBtn.MouseButton1Click:Connect(function() 
    Settings.EggFrame = not Settings.EggFrame
    update(eggFrameBtn, "EggFrame", "Egg Animation")
    SaveConfig()
    destroyEggFrame()
    if Settings.EggFrame then Notify("Hatching Animation", "Egg Animation : ON") 
    else Notify("Hatching Animation", "Turn ON Egg Animation to See Clear Gameplay!") end 
end)

eggFrameBtn.MouseButton2Click:Connect(function() collectDailyStuff() end)

-- Initial Load Actions
getgenv().AEVO_Loaded = true
if not getgenv().AEVO_Loaded then
    Settings.rStatus = Settings.rStatus + 1
    local t = os.date("!*t")
    local currentDate = string.format("%d-%d-%d", t.year, t.month, t.day)
    if Settings.LastExecDate ~= currentDate then
        if Settings.rStatus > 1 then
            SendDiscord(" has Executor AEVO Script (**x" .. Settings.rStatus .. "**) ", false, true)
        else
            SendDiscord(" has Executor AEVO Script (**x" .. Settings.rStatus .. "**) " .. os.date("%d/%m/%Y"), false, true)
        end
        Settings.LastExecDate = currentDate
    end
    SaveConfig()
    getgenv().AEVO_Loaded = true
    local c = Workspace:FindFirstChild("Client")
    local mf = c and c:FindFirstChild("Maps")
    local cm = mf and #mf:GetChildren() > 0 and mf:GetChildren()[1]
    if cm and Settings.MapSelected and cm.Name ~= Settings.MapSelected then 
        Bridge:FireServer("Teleport", "Spawn", Settings.MapSelected)
    end
end